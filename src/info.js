// ! Создание нового проекта на React-JS

// TODO Для создания нового приложения нужно открыть терминал в родительской для него папке и ввести "npx create-react-app my-app", где my-app это будет название создаваемой папки с полностью развернутым реактом

// -------------------------------------------------------------

// ! Создание нового проекта на React-TS

// TODO Для создания проекта используется команда "npx create-react-app --template typescript my-project", где my-project - название проекта.

// TODO Удаляем из src лишние файлы, чтобы остались только App.tsx, index.css, index.tsx, react-app-env.d.ts, setupTests.ts

// TODO Из index.tsx удаляем ссылки на reportWebVitals из импорта сверху и из запуска снизу

// TODO Возможно, также стоит удалить из index.tsx обертку <React.StrictMode> (ЭТО НЕ ТОЧНО)

// TODO Удалить из App.tsx лишние импорты и лишнее из return

// -------------------------------------------------------------

// ! Условный рендеринг

// TODO Для того чтобы задать отрисовку по условию используется логический оператор И, т.е. в {professions && <GroupList/>} <GroupList/> будет отрисован только, если professions приводится к булевому true

// -------------------------------------------------------------

// ! Передача параметров к компонент

// TODO Для передачи одного параметра в компонент используется запись <GroupList items={professions}/>. В дочернем компоненте при деструктуризации нужно получить компонент по тому же имени, с помощью записи ({ items })

// TODO Для передачи нескольких параметров в компонент, можно соединить новые параметры с объектом параметров дочернего компонента. Для этого используется запись {...user}. В дочернем компоненте при деструктуризации необходимо вызывать каждый из параметров в отдельности, с помощью записи ({_id, name, qualities})

// TODO Для задания значений по умолчанию для параметров используется defaultProps. GroupList.defaultProps = {valueProperty: "_id"}

// -------------------------------------------------------------

// ! Хук useState

// TODO useState перерисовывает компонент, согласно заданным усовиям. Позволяет задать перерисовывание элемента на любом уровне декомпозиции, в том числе и в итерируемых списках

// -------------------------------------------------------------

// ! Хук useEffect

// TODO useEffect выполняется каждый раз при первичной/повторной отрисовке и удалении компонента (на каждом этапе ЖЦКомпонента). Это его механизм по умолчанию. Для этого его нужно просто задать в качестве функции на верхнем уровне тела компонента.

// TODO Для того чтобы useEffect выполнялся только один раз при первой отрисовке, нужно передать ему вторым параметром пустой массив

// TODO Также в данный массив, вторым параметром, можно передать переменные, которые необходимо отслеживать и которые могут быть использованы в теле useEffect

// TODO Пример - useEffect(() => { validate(); }, [data]); Функция validate отработает каждый раз, при изменении переменной data.

// TODO В качестве отслеживаемых параметров в useEffect необходимо добавлять любые параметры, которые используются внутри useEffect и могут измениться за его пределами

// -------------------------------------------------------------

// ! Лайфхаки

// TODO Для добавления cursore:pointer на элемент, можно добавить ему в HTML/jsx role="button"

// TODO Запись columns[column].component || _.get(item, columns[column].path) означает: отобразить columns[column].component, если он существует, если не существует, отобразить _.get(item, columns[column].path)

// TODO Запись user => {} Означает выполнить функцию
// TODO Запись user => () Означает вернуть компонент

// TODO Быстро закомментировать кусок кода можно при помощи команды ctrl+/

// TODO Внести изменения во все одинаковые записи в файле можно при помощи команды ctrl+F2

// TODO Обновить страницу можно с помощью window.location.reload()

// TODO Для исправления ошибки с неконтролируемыми данными (A component is changing an uncontrolled input to be controlled.), когда в компонент передается переменная, заданная через useState, можно задать (|| "") при её передаче (value: data[child.props.name] || "" )

// TODO history.goBack() позволяет перенаправить пользователя на предыдущую страницу

// =============================================================

// ! ESLint

// TODO Установить ESLint с помощью команды eslint --init и ответить на вопросы

// TODO Обновить файл .eslintrc.js и добавить .prettierrc.js с помощью старых проектов

// TODO Добавить в раздел scripts в package.json строку "format": "npx prettier --write ."

// TODO Запустить npm run format

// TODO Перезапустить локальный сервер

// -------------------------------------------------------------

// ! lodash

// TODO В компоненте pagination, lodash использован с методом range, который создает массив натуральных чисел от заданного до заданного значения, не включая последнее

// TODO В компоненте usersListPage, lodash использован с методом orderBy для сортировки. В метод orderBy необходимо передать 3 параметра:
// первым параметром нужно передать массив для сортировки,
// вторым параметром нужно передать массив параметров, по которым будет осуществлена сортировка
// третьим параметром нужно передать массив с направлением сортировки - по возрастанию ["asc"] или по убыванию ["desc"]

// TODO В компоненте TableBody, lodash использован с методом get для получения данных в тех случаях, когда по заданному пути хранятся не сами данные, а ссылки на них. Первым параметром в get нужно передать объект, хранящий данные и ссылки, а вторым путь на сторонний источник

// TODO В уроке 7, метод "_(posts).slice(0).take(search.count).value()", выводит "search.count" элементов массива posts, начиная с 0.

// -------------------------------------------------------------

// ! React Router Dom

// TODO Для установки React Router Dom нужно ввести команду npm i react-router-dom@5.3.0

// TODO Для настройки маршрутизации необходимо:
// в файле index.js обернуть основной компонент и React.StrictMode в тег BrowserRouter (<React.StrictMode> <BrowserRouter> <App /> </BrowserRouter> </React.StrictMode>) (ИЛИ НАОБОРОТ???)
// в файле app.js импортировать роутер (import { Route } from "react-router-dom";), а также создать компоненты маршрутизатора со ссылками на путь и компонент (<Route path="/dashboard" component={Dashboard} />)
// ! если нужно передавать какие-то параметры в компонент, то для передачи компонента нужно использовать не атрибут component, а атрибут render (<Route path="/dashboard" render={props => (<Dashboard {...props} isAdmin={false} />)
// установить параметр exact для всех страниц, имеющих дочерние подстраницы (напр. - главная), который означает что компонент будет отображаться только при полном совпадении пути, в противном случае, если напр. задана настройка path="/posts", то компонент будет отображаться и на странице с путем /posts и на странице с путем /posts/32
// другой способ избежать дублирования компонентов состоит в том, чтобы имортировать { Route, Switch } из "react-router-dom", обернуть все компоненты Route в компонент Switch и расположить все компонены в порядке от нижнего уровня декомпозиции к верхнему.
// ! Для корректной работы редиректа главную страницу необходимо располагать в начале с атрибутом exact

// TODO Тег Link - это аналог тега а и используется, для того чтобы сообщить Реакту, что необходимо изменить текущий путь (из адресной строки) на тот, который соответствует заданному внутри тега, в атрибуте to. В противном случае, при использовании а, перезагружается вся страница

// TODO Опциональный параметр при маршрутизации отображает страницу, как при наличии данного параметра в адресной строке, так и без него. Напр., при path="/posts/:PostId?, компонент отобразится, как при /posts/21, так и при /posts

// TODO Можно передавать несколько опциональных параметров. Например - /posts/:PostId?/:commentId?. В этом случае, в match.params создадутся две переменные PostId и commentId, а рендериться страницы будут в порядке установленного пути, т.е. сначала коммент, если он есть, если нет, то пост, если поста нет, то страница posts

// =============================================================

// ! Query-параметры (параметры запроса)

// TODO Query-параметры используются для того, чтобы сразу при открытии страницы передать определенные параметры, которые тем или иным образом изменят содержимое отображаемого компонента (кол-во эл-ов на странице или параметры сортировки)

// TODO Для корректной обработки Query-параметров нужно установить дополнительный пакет (npm i query-string) и импортировать его на страницу, где он будет использоваться (import query from "query-string");

// TODO Query-параметры задаются в адресной строке и передаются в компонент страницы в параметр location.search. Например, "http://localhost:3000/posts?sortBy=newest&count=1" передаст в "location.search" "?sortBy=newest&count=1"

// TODO Для обработки принятых Query-параметров используется метод query.parse(location.search). Он преобразует "?sortBy=newest&count=1" в объект "{count: '1', sortBy: 'newest'}"

// =============================================================

// ! Redirect используется для переадресации с одной страницы на другую на этапе её загрузки

// TODO Для подключения, Redirect нужно импортировать из react-router-dom

// ! Переадресация с ненайденных страниц

// TODO Redirect устанавливается в конце Switch и в атрибут to ему передается страница, на которую нужно переадресовывать со всех ненайденных страниц (<Redirect to="/404" />)
// Также, перед Redirect в Switch необходимо создать саму страницу,на которую будет осуществлена переадресация

// ! Переадресация с конкретной страницы

// TODO Для переадресации с конкретной страницы на другую также используется Redirect с атрибутами from и to. Например, "<Redirect from="/admin" to="/dashboard" />" будет автоматически перекидывать со страницы admin на страницу dashboard

// =============================================================

// ! Объект history. Служит для переадресация по условию/событию

// TODO Для того чтобы настроить переадресацию по событию, нужно повесить событие на объекты, а в исполняемую функцию добавить
// ! history.push("/posts")
// TODO В этом случае, по наступлении события (напр. по клику на кнопку), произойдет переадресация на posts
// history - это один из параметров компонента с тегом Route. Для его получения можно либо получить его из деструктуризации props либо использовать хук useHistory:
// import { useHistory } from "react-router-dom";
// const history = useHistory()

// TODO Способ выше позволяет верутся к прежней странице по нажатии кнопки "вернуться" в браузере

// TODO Если необходимо исключить возможность возврата на прежнюю страницу, то нужно использовать replace вместо push

// ! Для того чтобы иметь возможность передавать history между компонентами, нужно установить пакет history (npm i history@4.9.0), создать утилитку createBrowserHistory (src\utils\history.js), затем заменить в index.js BrowserRouter на Router и добавить ему параметр  history={history} (с импортом из утилитки).

// =============================================================

// ! Хуки react-router-dom

// TODO Хук useHistory используется для доступа к атрибуту history напрямую из дочернего элемента:
// import { useHistory } from "react-router-dom";
// const history = useHistory()

// TODO Хук useParams используется для доступа к атрибуту match.params напрямую из дочернего элемента:
// import { useParams } from "react-router-dom";
// const params = useParams()

// TODO Хук useLocation используется для доступа к атрибуту location.search напрямую из дочернего элемента

// =============================================================

// ! Множественный select

// TODO Сначала нужно установить пакет npm i react-select

// TODO Шаблоны кода можно взять с https://react-select.com/home

// TODO В файле multiSelectField мы приводим поля наших данных из api.qualities к полям, требуемым пакетом react-select
// options = [{ value: 'chocolate', label: 'Chocolate' }]

// =============================================================

// ! Библиотека валидаторов Yup

// TODO Сначала нужно установить пакет npm i yup

// TODO Затем импортировать yup в компонент, где он будет использоваться, при помощи import * as yup from "yup";

// TODO Пример настройки схемы валидации сделан в компоненте LoginForm в переменной validateScheme, а запуск в переменной validate (оба закомментированы)

// TODO Настройка email: yup.string().required("Необходимо ввести email").email("Email введен некорректно") означает:
// Настройка установлена для поля формы с name="email"
// Поле "email" имеет тип данных string
// У поля две проверки required и email, при этом сначала выполняется required и только если проверка прошла, то проверяется email
// Проверка required задана в yup и проверяет на непустое значение
// Проверка email задана в yup и проверяет на правильность заполнения электронной почты
// В скобках указывается текст ошибки, который будет выводиться пользователю

// TODO Yup работает в ассинхронном режиме, поэтому для его запуска используется запись
// validateScheme.validate(data).then(() => setErrors({})).catch(err => setErrors({ [err.path]: err.message }));
// В then указывается, что делать если валидация пройдена успешно. В примере - устанавливать пустой объект переменной errors
// В catch указывается, что делать при возникновении ошибки. В примере - добавлять в объект ошибки поля с ключом/значением, соответсвующим полю и текту ошибки

// TODO Yup выдаёт ошибки последовательно, снизу вверх согласно схеме валидации, поэтому и задавать их нужно соответственно

/*
Константа из примера
const validateScheme = yup.object().shape({
password: yup.string().required("Необходимо ввести пароль").matches(/(?=.*[0-9])(?=.*[!@#$%^&*])(?=.*[а-яa-z])(?=.*[А-ЯA-Z])[0-9а-яa-zА-ЯA-Z!@#$%^&*]{8,}/g, "Пароль должен содержать не меньше 8 символов, в том числе заглавную и строчную буквы, спецсимвол и число"),
email: yup.string().required("Необходимо ввести email").email("Email введен некорректно")
});
Из переменной validate, из примера
validateScheme.validate(data).then(() => setErrors({})).catch(err => setErrors({ [err.path]: err.message }));
*/

// =============================================================

// ! Хук useRef()

// TODO useRef() это, по сути, просто универсальный контейнер для данных, useRef() от useState() отличаются только тем, что изменение useState вызывает повторную отрисовку родительского компонента, а useRef нет, однако сам useRef, при изменении своего значения, отрисовывается заново.

// TODO useRef() используется для того, чтобы сохранить какое-либо значение и хранить/изменять его в течение всей жизни компонента, т.е. данный объет обнулится только при повторной отрисовке всего компонента или при обновлении всей страницы целиком. При изменении значения не произойдет повторный рендер компонента, но сам объект будет перерисован.

// TODO Для обращения к текущему состоянию объекта, заданного с помощью useRef(), используется obj.current

// --------------------

// TODO 1-ый способ применения

// TODO useRef() может использоваться для подсчета количества рендеров компонента. Для этого нужно использовать useRef() и useEffect() без отслеживаемого параметра. Пример в уроке 11 в \src\app\components\examples\useRef\renderCount.

// const renderCount = useRef(0);
// useEffect(() => {
//     renderCount.current++;
// });

// TODO Пример релизован в уроке 11 в \src\app\components\examples\useRef\renderCount

// --------------------

// TODO 2-ой способ применения

// TODO useRef() может использоваться для отображения предыдущего состояния объекта/компонента.

// const [someState, setSomeState] = useState("false");
// TODO Создаем пустую переменную prevState с хуком useRef
// const prevState = useRef("");
// TODO Устанавливаем, чтобы переменная prevState принимала в себя значение переменной до её изменения
// useEffect(() => {
//     prevState.current = someState;
// }, [someState]);
// TODO В результате someState будет хранить значение переменной после изменения, а prevState до.

// ! Также может быть использован для того, чтобы поймать компонент в состоянии после первой отрисовки

// TODO Пример релизован в уроке 11 в \src\app\components\examples\useRef\prevState

// --------------------

// TODO 3-ий способ применения

// TODO useRef() может использоваться для получения элемента DOM-дерева в переменную, аналогично document.body.querySelector("className")

// TODO Объявлем переменную с хуком useRef и пустым значением
// const inputRef = useRef();
// TODO Прикрепляем переменную к jsx-элементу, с помощью атрибута ref
// <input ref={inputRef} />
// TODO В результате переменна inputRef будет хранить указанный input

// ! Также может быть использован для установки фокуса на определенных элемент, перемещения экрана по заданным параметрам или для изменения любого из стилей элемента при помощи атрибута style.

// TODO Пример релизован в уроке 11 в \src\app\components\examples\useRef\programmableActions

// =============================================================

// ! Хук useMemo()

// TODO useMemo() позволяет избежать многократного выполнения ресурсозатратных вычислений указанной функции при каждом рендере внутренних частей компонента, сохраняя результат данной фукнции, и установив, чтобы она пересчитывалась только при изменении конкретной переменной, сколько бы не ререндерился родительский компонент.

// TODO В примере (const fact = useMemo(() => calcFactorial(value), [value]);) установлено, чтобы переменная fact сохраняла результат выполнения функции calcFactorial и пересчитывалась только при изменении значения value

// ! Без необходимости лучше не использовать, т.к. данный хук также нагружает ресурсы системы

// TODO Пример релизован в уроке 11 в \src\app\components\examples\useMemo\complexCalculate

// =============================================================

// ! Хук useCallback()

// TODO useCallback() также позволяет избежать многократного выполнения ресурсозатратных вычислений указанной функции при каждом рендере внутренних частей компонента, сохраняя функцию, и установив, чтобы она пересчитывалась только при изменении конкретной переменной, сколько бы не ререндерился родительский компонент.

// TODO Полностью аналогична useMemo(), но useMemo() хранит результат выполнения функции, а useCallback() саму функцию.

// ! Без необходимости лучше не использовать, т.к. данный хук также нагружает ресурсы системы

// TODO Пример релизован в уроке 11 в \src\app\components\examples\useCallback\useCallBackExample

// =============================================================

// ! Higher-Order Component, HOC, Компонент высшего порядка

// TODO Компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент.

// TODO HOC следует называть, начиная с with

// --------------------

// TODO HOC можно использовать для установки дополнительной логики отображения компонента, т.е. поставить в HOC дополнительное условие и менять компонент в зависимости от этого условия

// TODO В примере реализован аналог логики отображения/скрытия компонента в зависимости от условия (param && <Component/> )

// TODO Пример релизован в уроке 11 в \src\app\components\examples\hoc\withLogin

// --------------------

// TODO В другом примере реализована логика HOC, который реализует обертку заданного компонента другим компонентом и добавление ему дополнительных параметров

// TODO Пример релизован в уроке 11 в \src\app\components\examples\hoc\withPropsStyles

// =============================================================

// ! React.Memo()

// TODO React.Memo() - HOC, который позволяет избежать многократной отрисовки компонента, ограничив его повторную отрисовку случаями, когда именяются его props.

// TODO Похожа на useMemo(), т.к. сохраняет отрисованный компонент, но в отличии от useMemo не является хуком.

// TODO В случае когда в компоненте, обернутом в React.Memo(), используется обработчик события, необходимо обернуть исполняемую обработчиком события функцию в useCallback, т.к. наступление события инициирует повторное создание экземпляра функции, которое, в свою очередь, инициирует ререндер компонента, т.к. исполняемая функция является частью props. useCallback, в этом случае сохраняет экзепляр функции, исключая его повторное создание, что, в свою очередь, позволяет исключить ререндер компонента.

// TODO Также есть возможность передать в React.Memo() вторым параметром функцию сверки (в примере - areEqual) и в этой функции задать полностью произвольные параметры ререндеринга. В данном случае ререндер будет происходить только в тех случаях, когда происходит стандартный вызов ререндеринга и данная функция будет возвращать true.

// TODO Если функция для сверки не задана, то поверхностная сверка выполняется по стандартному алгоритму (https://github.com/facebook/react/blob/v16.8.6/packages/shared/shallowEqual.js)

// ! Без необходимости лучше не использовать, т.к. данный HOC также нагружает ресурсы системы

// TODO Пример релизован в уроке 11 в \src\app\components\examples\memo\memoWithUseCallbackExample

// =============================================================

// ! React.cloneElement()

// TODO React.cloneElement() - создает новую копию указанного элемента, с возможнотью передачи в неё дополнительных параметорв или перезаписи существующих

// TODO Пример React.cloneElement() релизован в уроке 11 в \src\app\components\examples\cloneElement\cloneElementExample

// =============================================================

// ! Children

// TODO children, которые хранятся в props, содержат данные о дочерних элементах в формате "только для чтения"

// TODO Для преобразования props.children используется утилита React.Children

// TODO React.Children.map(children, function[(thisArg)]) - вызывает произвольную функцию для каждого потомка

// TODO React.Children.count(children) возвращает общее количество компонентов в children

// TODO React.Children.toArray(children) преобразует children в массив

// TODO Пример React.Children релизован в уроке 11 в \src\app\components\examples\children\reactChildrenExample

// =============================================================

// ! Структуры данных

// ! Нормализация/денормализация

// TODO Необходимо, чтобы сущности, имеющие самодостаточное наполнение хранились в едином месте и использовались в посредством ссылок на единый общий источник. Отсутствие данного принципа, когда одни и те же данные существуют в разных местах, называют "Избыточность и несогласованность данных".

// TODO Ниже представлен пример избыточности данных. Категория "Холодильники" существует в двух разных местах в виде двух разных объектов. В данном случае, когда подкатегории могут повторяться в двух и более разных категориях, необходимо вынести подкатегории в отдельный массив, и в категориях хранить ссылки на конкретные его элементы.

/*
categories1 = [
    {
        "id": "89543fsd34olk04",
        "name": "kitchen",
        "label": "Кухонная техника",
        "img": "https://i.yapx.ru/TzOCW.jpg",
        "subcategories": [
            {
                "id": "89543fsd34olk05",
                "name": "fridges",
                "label": "Холодильники",
                "img": "https://i.yapx.ru/TzOCV.jpg"
            },
            {
                "id": "89543fsd34olk06",
                "name": "dishwashers",
                "label": "Посудомоечные машины",
                "img": "https://i.yapx.ru/TzOCU.jpg"
            }
        ]
    }
]

categories2 = [
    {
        "id": "89543fsd34olk04",
        "name": "kitchen",
        "label": "Бытовая техника",
        "img": "https://i.yapx.ru/TzOCW.jpg",
        "subcategories": [
            {
                "id": "89543fsd34olk05",
                "name": "fridges",
                "label": "Холодильники",
                "img": "https://i.yapx.ru/TzOCV.jpg"
            },
            {
                    "id": "89543fsd34olk08",
                    "name": "microwaves",
                    "label": "Микроволновые печи",
                    "img": "https://i.yapx.ru/TzOCT.jpg"
            }
        ]
    }
]
*/

// TODO Денормализация - подход при котором может быть несколько уровней вложенности данных, как в примере выше. Нормализация - наоборот, подразумевает выделение всех уровней вложенности в отдельные сущености (отдельная сущность для категорий, отдельная для подкатегорий). При нормализации в объекты дочернего смыслового уровня, может добавлятся ссылка на связанный родительский элемент. Например, как в примере ниже.

/*
{
"id": "89543fsd34olk08",
"parent-category-id": "89543fsd34olk04",
"name": "microwaves",
"label": "Микроволновые печи",
"img": "https://i.yapx.ru/TzOCT.jpg"
}
*/

// -----------------

// ! Тип связи "Один к одному"

// TODO Суть - и те и другие данные относятся к одному и тому же объекту, но хранятся в разных сущностях и связываются по единому полю. В примере выше, данные связаны по полю "id" в родительском объекте и полю "parent-category-id" в дочернем объекте

// TODO При связи "Один к одному", как в примере с категориями, нормализация имеет смысл только с целью разделения объекта с большим количеством данных на несколько сущностей по критерию статичности данных, т.е. оставить в одной сущности данные, которые не подлежат имзенению, и выделить в другую(ие) те, что изменяются в проекте. Либо разделить на более изменяемые и менее изменяемые.

// -----------------

// ! Тип связи "Один ко многим"

// ! Пример в денормализованном виде

/*
{
    "_id": "joe",
    "name": "Joe Bookreader",
    "addresses": [
        {
        "street": "123 Fake Street",
        "city": "Faketon",
        "state": "MA",
        "zip": "12345"
    },
    {
        "street": "1 Some Other Street",
        "city": "Boston",
        "state": "MA",
        "zip": "12345"
    }
    ]
}
*/

// ! Пример в нормализованном виде

/*
{
    _id: "joe",
    name: "Joe Bookreader"
}

{
    parent_id: "joe", // reference to parent document
    street: "123 Fake Street",
    city: "Faketon",
    state: "MA",
    zip: "12345"
}
{
    parent_id: "joe",
    street: "1 Some Other Street",
    city: "Boston",
    state: "MA",
    zip: "12345"
}
*/

// TODO. В этом случае имеет смысл нормализовать данные, если нет необходимости работать со всем массивом данных обеих сущностей

// -----------------

// ! Тип связи "Многие ко многим"

// TODO Суть - В разных сущностях хранятся разные данные. Например, в курсовом проекте, в одной сущности хранятся данные о пользователях, в другой хранятся данные о всех возможных качествах. При этом, один пользователь может иметь одно или несколько (не все) качеств, и нам нет необходимости обрабатывать весь массив качеств при работе с конкретным пользователем. Аналогично с качествами, одно качество может относится одному и более пользователям.

// TODO. В этом случае также имеет смысл нормализовать данные

// -----------------

// ! По умолчанию рекомендуется использовать нормализацию со связыванием по id, а денормализацию добавлять точечно, там где это нужно для оптимизации.

// =============================================================

// ! Взаимодействие с сервером и MongoDB

// TODO на этапе разработки, при работе с MongoDB, требуется запускать базу данных запущенной отдельно. Для этого нужно:
// Развернуть базу данных отдельным проектом
// В проекте с базой данных изменить команду "dev" в package.json на следующую: "dev": "set DEBUG=server:* & nodemon ./bin/www".
// При нажатом shift, нажать правой кнопкой мыши на папку с установленным сервером и БД (в проекте обучения это папка server) и выбрать "Открыть окно PowerShell здесь"
// ! Ввести команду npm run dev
// Не закрывать окно с PowerShell до окончания работы

// TODO Данные, хранящиеся в MongoDB, расположены по адресу http://localhost:4000/api/v1/
// api и v1 не являются обязательными, но необходимы для прослеживаемости и функционирования различных версий проекта, так что лучше их указывать.
// TODO Для получения всей сущности необходимо ввести запрос по адресу http://localhost:4000/api/v1/user, где user - это название сущности в базе данных
// TODO Для получения конкретного объекта необходимо ввести запрос по адресу http://localhost:4000/api/v1/user/6327bbec333c5a6f341d4cea, где 6327bbec333c5a6f341d4cea - это id объекта из MongoDB (не из json!!!)

// TODO Взаимодействие с сервером осуществляется по одному из 4х сценариев:
// ? get - запрос существующих данных
// ? post - создание новой записи
// ? put - замена существующих данных
// ? delete - удаление существующих данных

// TODO Отправка данных на сервер осуществляется с помощью axios.put(qualityEndPoint, data), где qualityEndPoint, URL любого уровня глубины, а data - данные на которые нужно заменить то, что там сейчас находится.

// =============================================================

// ! Ошибки при запросе данных с сервера

// TODO Ожидаемые ошибки - ошибки клиента (реакт-приложения), имеют код 4хх (404 и др.), говорят о том, что проблема на уровне данных

// TODO Неожиданные ошибки - ошибки сервера, имеют код 5хх, говорят о том, что проблема на уровне работоспособности сервера

// TODO Статусы до 400 не являются ошибками

// TODO Перехватчик axios.interceptors позволяет отлавливать все вызовы axios и задавать для них общий сценарий обработки. Пример с перехватом ошибок в уроке 14 в src\app\services\http.service.js. Аналогично можно настроить перехват объекта res, который будет отлавливать каждый успешный ответ от сервера, преобразовывать по заданному алгоритму и возвращать измененные данные.

// ! Для логирования ошибок, т.е. настройки постоянного перехвата возникающих ошибок и аккумулирования их в единой среде для последующей обработки, можно использовать сервис Sentry.io. Актуально, когда нужно поддерживать функциональность существующего приложения.
// Переиспользуемый компоненты, завязанный на Sentry.io, реализован в уроке 14 в src\app\services\logService.js

// TODO Отображение ошибок для пользователя можно настроить с помощью toastify:
// Сначала его нужно установить с помощью npm i react-toastify@8.1.0
// В App.js нужно импортировать (import { ToastContainer } from "react-toastify";) и (import 'react-toastify/dist/ReactToastify.css';), а также поместить компонент (<ToastContainer />) перед закрытием тега App
// В утилите, собирающей ошибки (в уроке 14 в src\app\services\httpService.js) нужно импортировать import { toast } from "react-toastify";
// Использовать можно по тому же принципу, что и console.log (toast.error("Ошибка сервера"))
// Различные методы объекта toast (toast.error, toast.info и т.д.) задают различное оформление уведомления пользователю

// ! Также с помощью toastify можно настроить любые уведомления пользователю, где это необходимо.

// =============================================================

// ! Кастомные хуки

// TODO Кастомный хук - это переиспользуемый компонент, содержащий набор функции, но возвращающий не HTML, а какие либо-данные (переменные/функции/объекты). Кастомный хук называют начиная с use. Пример реализован в уроке 14 в src\app\hooks\useForm.jsx

// =============================================================

// ! Контекст

// TODO Контекст - это инструментарий, позволяющий получить доступ к кокретному объекту во всех местах, вложенных в заданную область применения

// TODO Для использования контекста необходимо инициализировать переменную контекста в кастомный хук и на верхнем уровне обернуть в соответствующий тег те компоненты, где этот контекст будет использоваться.
// Пример инициализации реализован в src\app\hooks\useQualities.jsx в уроке 14, обертка задана в Арр
// Верхним уровнем для обертки не обязательно должен быть Арр, главное, чтобы этот уровень содержал всю область применения контекста

// TODO Для использования данных, заданный в контексте нужно создать соответствующую переменную (const { qualities } = useQualities()) в компоненте, в котором требуются данные.
// Пример реализован в уроке 14 в src\app\pages\qualititesList.jsx и в других компонентах.

// =============================================================

// ! Пессимистическое и оптимистическое обновление данных

// TODO Пессимистическое обновление данных подразумевает ожидание получения ответа от сервера и только после этого их отрисовку

// TODO Оптимистическое обновление данных подразумевает отрисовку результата до получения ответа от сервера и отрисовку обратно, в случае возникновения ошибки

// =============================================================

// ! Firebase

// TODO Firebase - ресурс для удаленного хранения и использования БД

// TODO Для подключения Firebase необходимо:
// Создать проект на сайте Firebase
// В разделе build выбрать Realtime Database
// В открывшемся окне нажать Create Database
// Выбрать ближайший сервер и тестовый/рабочий режим работы
// Наполнить базу данных (данные вносятся без кавычек)
// ! В Firebase необходимо хранить данные в формате объекта объектов, а не массива объектов

// Документация Firebase (REST API) https://firebase.google.com/docs/reference/rest/database

// TODO Для обращения к данным Firebase используется путь https://fast-company-firebase-eebb5-default-rtdb.asia-southeast1.firebasedatabase.app/profession.json, где
// всё, что до profession, это путь из проекта в Firebase
// profession - это название сущности из БД (допускается указывать уровни вложенности через "/")
// .json необходимо добавлять к каждому запросу в конец

// TODO Если БД настроена корректно, то для перехода на Firebase достаточно перенести наполнение БД, сменить значение в переменной "URL по умолчанию", а также добавить дополнительный interceptors (см. src\services\httpService.js), который будет добавлять .json в конец каждого из запросов.
// Также может потребоваться настроить функцию транформации данных между форматами "массив объектов" и "объект объектов" (пример в функции transformData в том же файле)

// ! Утилита, которая берет базу в формате json-файла с массивом объектов и загружает его в Firebase в формате объекта объектов, расположена в src\utils\mockData.js
// Её также можно использовать, чтобы возвращать базу данных к исходным параметрам.

// ! Фильтрация данных при запросе из Firebase - https://firebase.google.com/docs/database/rest/retrieve-data#section-rest-filtering. Реализована в getComments в src\services\commentService.js (также необходимо добавить дополнительный параметр indexOn в rules в Firebase) (также требуется добавить исключение в .eslintrc.js для двойных кавычек)

// =============================================================

// ! Авторизация и аутентификация (на примере Firebase)

// TODO Для настройки авторизации через Firebase нужно открыть внутри проекта на сайте Firebase выбрать раздел build\Authentication, затем выбрать тип входа в систему (в примере далее выбран нативный вход по почте и паролю)
// Будет на выбор два переключателя. Первый необходимо включить, второй отвечает за отправку подтверждающего письма на электронную почту. Его нужно выключить.

// TODO Добавлять новых пользователей и работать с существующими можно напрямую через Firebase в разделе Authentication, на вкладке users

// TODO В проекте создан кастомный хук useAuth, отвечающий за регистрацию, т.е. создание нового элемента в Firebase (в базе регистрации и в базе пользователей) и добавлении нового пользователя для отображения. Подключен в App, в RegisterForm, в loginForm

// TODO Предоставление доступа в Firebase реализовано через правила, которые задаются в проекте Firebase, в Realtime Database, на вкладке Rules
// В учебном прокте задан следующий набор правил:
// К просмотру сущности пользователей имеют доступ зарегистрированные пользователи, к редактированию допускается только данные своего пользователя
// Сущности профессий и качеств доступны для просмотра всем и для редактирования никому
// {
//     "rules": {
//       "user": {
//         ".read": "auth != null",
//         "$uid":{
//             ".write": "$uid === auth.uid"
//             }
//           },
//       "quality": {
//         ".read": true,
//           ".write": false
//       },
//       "profession": {
//         ".read": true,
//           ".write": false
//       }
//     }
// }

// TODO Функционал обновления токена и предоставления доступа, согласно токену и правилам, реализован в httpService, внутри interceptors.request, чтобы обновление токена происходило при каждом запросе пользователя (по любому поводу) по мере истечения его срока жизни.

// TODO Защищенные пути используются для того, чтобы автоматически переадрисовывать пользователя со страницы, к которой у него нет прав доступа. Реализовано в src\components\common\protectedRoutes.jsx и использовано в App

// TODO Функционал выхода из учетной записи реализован в функции logout в useAuth и применен в src\components\ui\navProfile.jsx и в src\layouts\logout.jsx

// TODO Правило ниже, заданное в rules, необходимо, чтобы запретить удаление комментариев, написанных другими пользователями
// "$cid": {".write": "auth != null && ((data.child('userId').val() === auth.uid)||(newData.child('userId').val() === auth.uid))"}

// =============================================================

// ! Redux - теория.

// ------------------------------

// ! Функциональное программирование.

// TODO Суть подхода заключается в том, что мы не сохраняем данные в промежуточных объектах, а всю логику задаем цепочкой из последовательно выполняемых промежуточных функций с минимальным функционалом у каждой.

// TODO Метод compose (импортируется из lodash/fp) используется для последовательного выполнения функций (пример в уроке 18).
// TODO Функции в compose выполняются в обратном порядке, относительно их записи.
// TODO Метод pipe делает то же самое, но функции выполняются в прямом порядке, относительно их записи.
// Стандартная запись - half(square(double(2)))  - Удвоить, возвести в квадрат, вычислить половину = 8
// Аналогичная запись - compose(half, square, double)  - Удвоить, возвести в квадрат, вычислить половину = 8
// Аналогичная запись - pipe(double, square, half)  - Удвоить, возвести в квадрат, вычислить половину = 8
// Первоначальный аргумент выполнения, задается при вызове родительской функции: const MathCalcPipe = pipe(double, square, half); MathCalcPipe(2)

// ------------------------------

// ! Каррирование – это трансформация, которая превращает вызов f (a, b, c) в f (a) (b) (c).

// TODO Ниже представлен пример функции до и после каррирования.
// const divideBeforeCarr = (num1, num2) => num1 / num2;
// const divideAfterCarr = (num2) => {
//     return function (num1) {
//         return num1 / num2
//     }
// }

// TODO Функцию divideBeforeCarr нельзя передать в метод pipe, т.к. pipe работает только с функциями, принимающими в себя один аргумент.
// TODO После изменения на divideAfterCarr, она будет принимать в себя результат выполнения предыдущих функций и выполнять деление на num2.
// TODO В результате, мы можем сделать запись pipe(double, square, half, divideAfterCarr(4)) - Удвоить, возвести в квадрат, вычислить половину, разделить на 4 = 2.

// ------------------------------

// ! Чистые функции (pure functions).

// TODO Чистой функцией называется та функция, которая не зависит от внешних объектов, т.е. возвращает один и тот же результат, при условии получения одних и тех же аргументов.
// TODO Пример чистой функции: const double = number => number * 2;
// TODO Пример нечистой функции: const double = number => number * Math.random();

// ! Для корректного функционирования Redux необходимо, чтобы все функции, которые он использует, были чистыми.

// ------------------------------

// ! Неизменяемый объект

// TODO Суть принципа заключается в том, что, для того, чтобы изменить параметры существующего объекта, мы не вносим в него изменения, а каждый раз создаем новый объект с измененными параметрами (данный принцип по умолчанию вшит в useState)
// const obj1 = { id: 2 };
// const obj2 = { ...obj1, name: "Me" };
// console.log("obj1", obj1);
// console.log("obj2", obj2);

// TODO При наличии вложенной структуры у объектов, необходимо использовать spread-оператор как на верхнем, так и на вложенном уровне
// const obj1 = { id: 2, author: { name: "anonim" } }
// const obj2 = { ...obj1, author: { ...obj1.author }, joy: true }
// console.log("obj1", obj1);
// console.log("obj2", obj2);

// ! Для корректного функционирования Redux необходимо использовать данный принцип

// ! В документации https://redux-toolkit.js.org/api/createReducer указано, какие типы нужно использовать с TypeScript

// ------------------------------

// ! Redux - внедрение.

// ! Установка:
// npm install @reduxjs/toolkit
// npm i react-redux

// TODO Создаем rootReduser и createStore с reducer в файле createStore.js

// TODO Инициализируем store и оборачиваем весь проект в Provider в файле index.js

// TODO Перевод сущности на Redux на примере src\store\qualities.js:
// Создаем Slice для сущности и добавляем её в combineReducers в createStore.js
// Наполняем qualities.js функционалом
// Подключаем в App через useDispatch() и useEffect
// Заменяем везде, где сущность вызывалась.
// В компоненте QualitiesList реализован функционал, на случай изменения данных на сервере, пока пользователь находится на странице (в противном случае они запрашиваются единожды, при монтировании App), согласно которому qualities повторно запрашиваются с сервера при монтировании компонента QualitiesList.

// =============================================================

// ! Переход на React Router v6 (на примере проекта из У21)

// TODO 1. Установить пакет
// npm i react-router-dom@6
// Это приведёт к тому, что приложение в текущем виде работать перестанет

// TODO 2. Везде заменить <Switch> на <Routes> (в том числе в импорте).

// TODO 3. Везде удалить exact. Exact отвечал за установку полного соответсвия пути. В RR6 он установлен по умолчанию.

// TODO 4. Везде изменить синтаксис Route и ProtectedRoute.
// TODO 4.1. component заменить на element
// TODO 4.2. Компонент передавать не ссылкой (PostPage), а jsx-элементом (<PostPage />)
// Было <Route path={path + "/:postId"} component={PostPage} />
// Стало <Route path={path + "/:postId"} element={<PostPage />} />

// TODO 5. Везде закомментировать Redirect, т.к. он был исключён (рефакторинг будет далее)

// TODO 6. Везде убрать useRouteMatch (если был)

// TODO 7. Везде закомментировать useHistory и использование history (рефакторинг будет далее)

// TODO 8. При наличии вложенных Route'ов, необходимо в родительском Route'е добавить "/*", а в дочернем исключить из пути родительскую часть
// Родительский Route был: <Route path='/auth' element={<AuthLayout />} />
// Родительский Route стал: <Route path='/auth/*' element={<AuthLayout />} />
// Дочерний Route был: <Route path = {"auth" + "/signup"} element={<SignUpPage />} />
// Дочерний Route стал: <Route path={"/signup"} element={<SignUpPage />} />

// TODO 9. Переделать структуру относительных Route'ов (/posts/:id?), когда, в зависимости от пути в адресной строке, отображалась конкретная страница конктеного элемента (пользователя, продукта)
// TODO 9.1 В родительском Route'е убрать относительный путь, и заменить его на "/*"
// Было: <Route path='/posts/:id?' element={<PostsLayout />} />
// Стало: <Route path='/posts/*' element={<PostsLayout />} />
// TODO 9.2 В дочернем Route'е исключить из пути родительскую часть
// Было: <Route path={"posts" + "/:postId"} element={<PostPage />} />
// Стало: <Route path={"/:postId"} element={<PostPage />} />
// TODO 9.3 Перенести Route'ы с дочернего уровня внутрь соответствующего Route'а в родительский, убрав лишние кавычки и слэши в начале path.
// Было: <Route path='/posts/*' element={<PostsLayout />} />
// Стало:
// <Route path='/posts/*' element={<PostsLayout />}>
// <Route path="" element={<PostsListPage />} />
// <Route path=":postId" element={<PostPage />} />
// </Route>
// TODO 9.4 Полностью убрать <Routes> и <Route> с дочернего уровня и заменить его на <Outlet />
// TODO 9.5 Относительный элемент (напр., id продукта) из адресной строки (который нужен для поиска нужно элемента в базе данных по этому id) необходимо запрашивать через useParams в компоненте, где он отрисовывается (const { postId } = useParams() в PostPage)

// ? <Outlet /> используется в дочернем компоненте, когда вложенные роуты установлены в родительском, для того чтобы указать, в каком месте данного дочернего компонента расположить тот компонент, который указан в родительском компоненте, в дочернем Route'е в element
// ? Другими словами для примера
// <Route index element={<MainPage />} />
// <Route path='auth' element={<AuthLayout />} >
// <Route path={"login"} element={<LoginPage />} />
// <Route path={"signup"} element={<SignUpPage />} />
// {/* <Redirect to={path + "/signup"} /> */}
// </Route>
// ? В данном примере <Outlet /> нужно указать внутри компонента AuthLayout для того, чтобы указать и вместо него будет подставляться либо компонент LoginPage, либо компонент SignUpPage, в зависимости от текущго адреса в адресной строке (login или signup), в том месте компонента AuthLayout, где необходимо расположить дочерние компоненты

// TODO 10. Убрать "/" из начала всех path, т.к. он устанавливается по умолчанию
// ? В Navigate начальный слэш имеет значение, т.к. он задает, как воспринимать адрес, указанный в to: как абсолютный или как относительный (с учетом родительского или без)

// TODO 11. Везде заменить path='' на index

// TODO 12. Если основной и вложенные Route'ы находятся в одном компоненте (и родительский и дочерний уровень указываются в одном компоненте), нужно убрать "/*" из конца path родительского уровня

// ? В Route родительского уровня не обязательно должен быть компонент

// TODO 13. Переделать Redirect.
// TODO 13.1 Синтаксис, когда Redirect нужно задать внутри Routes:
// TODO <Route path='*' element={<Navigate to={"/posts"} />} />
// TODO Согласно данному коду, система будет переадресовывать со всех адресов, кроме тех что указаны в других Route'ах, на "/posts"

// TODO 13.2 Синтаксис, когда Redirect нужно установить внутри компонента или когда нужно задать Redirect при динамической генерации созданием, т.е. когда перечень вложенных Route'ов, а определяется базой данных. В этом случае Redirect устанавливается внутри компонента.
// TODO if (loadingStatus !== "pending" && !post) {return <Navigate to="/posts" />}
// TODO Согласно данному коду, при выполнении указанного условия будет произведен редирект на "/posts"

// TODO 13.3 Синтаксис, когда нужно задать переадресацию с базовой страницы на дочерний вложенный Route
// <Route path='auth' element={<AuthLayout />} >
//     <Route index element={<Navigate to="/auth/signUp" />} />
//     <Route path={"signUp"} element={<SignUpPage />} />
// </Route>
// TODO Согласно данному коду, при переходе на http://localhost:3000/auth будет произведена автоматическая переадресация на http://localhost:3000/auth/signUp

// TODO 13.4 Переадресация вложенных Route'ов на заданный адрес производится аналогично п. 13.1
// <Route path='auth' element={<AuthLayout />} >
//     <Route path='*' element={<Navigate to={"/auth/signUp"} />} />
// </Route>
// TODO Согласно данному коду, при переходе на любую незаданную страницу "/auth/*" будет произведена переадресация на "/auth/signUp"

// TODO 14. Везде переделать useHistory на useNavigate, а history.push("/posts") на navigate("/posts", { replace: true })
// replace: true стирает историю браузера и запрещает возврат пользователя на предыдущую страницу
// ? navigate также поддерживает возврат на ранее посещенные страницы. navigate(-1) означает переадресацию на предыдущую страницу, а navigate(-2) на две страницы назад.

// TODO 15. ProtectedRoute реализуются проверкой, авторизован ли пользователь, с редиректом, если нет. Ниже пример из src\routes.jsx
// element: isLoggedIn ? (
//     <PostsLayout />
// ) : (
//     <Navigate to='/auth/login' state={{ referrer: location }} />
// )

// TODO 16. Ссылки в Link NavLink можно указывать относительно родительского Route'а, т.е. без родительского части
// ! Наличие или отсутсвие слэша в начале адреса (to) определяет, как будет восприниматься ссылка, как относительная или как абсолютная

// =============================================================

// ! Node.JS Основы (Урок 2 в учебных папках)

// TODO Для запуска JS-файла через терминал (без браузера) нужно ввести в терминал команду "node index" (index - название JS-файла), при открытой в терминале соответствующей папке проекта

// TODO Для подключения одного JS-файла к другому, используется команда require("./module"), где module - подключаемый файл. Оба файла должны находится в соответствующей папке проекта

// TODO Экспорт-импорт
// Для экспорта конкретных сущностей (напр., функций), используется структура module.exports = {addNote, getNotes}, где addNote, getNotes экспортируемые функции
// Для импорта сущностей используется команда const { addNote, getNotes } = require("./notes.controller")

// TODO Для подключения сторонних NodeJS модулей используется файл package.json. Для его первоначальной генерации нужно ввести команду npm init и ответить на вопросы (для корректной работы поле author должно быть заполнено в формате Evgeniy Sologub <elon_26@bk.ru>)

// TODO Модуль yargs (является базовым модулем для консольных приложений)
// Для установки используется команда npm i yargs
// Для подключения нужно добавить в index.js строку const yargs = require("yargs")
// Также рекомендуется установить npm i @types/yargs

// TODO Создание произвольных комманд
// Регистрация комманды с помощью yargs.command({})
// Внутрь объекта нужно передать 3 значения: command, describe, handler
// command - наименование комманды, с помощью которой она будет вызываться через консоль
// describe - описание команды, которое будет выводиться в перечне команд при вводе node index --help
// handler - функция, которая будет выполняться при вызове команды
// Помимо регистрации, команды также должны быть проиницилизированы, при помощи yargs.parse()

// TODO Для вызова конкретной команды нужно ввести в терминал "node index add" (index - название JS-файла, add - название команды), при открытой в терминале соответствующей папке проекта

// TODO Для того чтобы команда могла принимать параметры из консоли, внутрь объекта yargs.command({}) также нжуно передать builder
// builder - объект, в значения которого передаются объектами все доступные параметры команды
// Каждый параметр также является объектом, содержащим значения type, describe, demandOption
// type - тип данных принимаемого из консоли значения
// describe - описание параметра, которое будет выводиться в перечне опций при вводе node index add --help
// demandOption - задает, обязателен ли данный параметр для запуска команды
// Обработка полученных параметров должна быть задана в handler
// Вызов команды вместе с параметром осуществляется при помощи node index add --title=Hello (перед параметром ставиться "--", лишние пробелы не допускаются)

// TODO Сохранение данных в json-файл осуществляется при помощи команды fs.writeFile("./db.json", JSON.stringify(notes)
// fs предварительно нужно импортировать при помощи const fs = require("fs/promises")
// Пример функции, которая сначала запрашивает данные из json-файла, затем обновляет данные и затем перезаписывает json-файл:
/*
async function addNote(title) {
    const notes = require("./db.json")

    const note = {
        title,
        id: Date.now().toString()
    }

    notes.push(note)

    await fs.writeFile("./db.json", JSON.stringify(notes))
}
*/

// TODO Не рекомендуется использовать абсолютные пути, т.к. это может вызвать конфликты при работе на разных платформах. Путь лучше прописывать через запрос данных.
// Переписанный код находится в notes.controller.js (Урок 2)

// =============================================================

// ! Node.JS Дополнительные стантартные модули (Урок 2 в учебных папках)

// TODO Модуль export/import
// Для того, чтобы работал export/import, как в классическом js, нужно в package.json прописать строку "type": "module", а при импорте указывать расширение файлов (.js)
// Доступ к глобальным переменным __filename и __dirname, с использованием export/import осуществляется следующим образом:
// import path from "path";
// import { fileURLToPath } from "url";
// const __filename = fileURLToPath(import.meta.url)
// const __dirname = path.dirname(__filename)

// TODO Модуль os позволяет запросить различные параметры системы для платформы, на которой она запущена (см. refs\os.js)

// TODO Модуль path позволяет запросить различиные данные о местонахождении исполняемого файла (см. refs\path.js)

// TODO Модуль fs позволяет осуществлять различные действия с файлами и папками (см. refs\fs.js)

// =============================================================

// ! Web-сервер (Урок 4 в учебных папках)

// TODO Создание сервера на базе Node.JS осуществляется с помощью модуля и его метода createServer http (см. index.js).
// TODO Для запуска сервера используется метод listen

// TODO Создание кастомных скриптов осуществляется внутри package.json в блоке "scripts"
// TODO Скрипт "start": "node index.js", означает, что при вводе "npm start" будет выполнена команда "node index.js"

// TODO Для того чтобы сервер перезапускался автоматически при изменении кода, нужно:
// установить пакет npm i nodemon -D
// добавить в package.json скрипт "serve": "nodemon index.js"
// в дальнейшем запускать сервер при помощи команды "npm run serve"

// =============================================================

// ! Перевод Backend проекта на MongoDB

// TODO 1. Создаем папку client и перемещаем в неё все текущие файлы проекта
// TODO 2. Создаем папку server на одном уровне с client
// TODO 3. Переходим в папку server (cd server) и инициализируем проект (npm init), называем проект и оставляем остальное по умолчанию.
// TODO 4. Создаем в папке server app.js
// TODO 5. Делаем скрипт start в package.json ("start": "node app.js")
// TODO 6. Устанавливаем требуемые пакеты npm i express config mongoose chalk@4.1.2
// TODO 7. Открываем app.js и подключаем модули:
// const express = require("express");
// const mongoose = require("mongoose");
// const config = require("config");
// const chalk = require("chalk");
// TODO 8. Создаём внутри папки server папку config и в ней файл default.json, заносим туда {"port": 8080}
// TODO 9. Инициализируем приложение и устанавливаем слушатель на порт 8080:
// const app = express();
// const PORT = config.get("port") ?? 8080; (данный функционал автоматически импортирует указанную строку из config/default.json)
// app.listen(PORT, () => {console.log(chalk.green("Server has been started"));});
// TODO 10. Настраиваем среду разработки:
// npm i -D nodemon cross-env
// Меняем скрипт start и создаем скрипт serve в package.json на:
// "start": "cross-env NODE_ENV=production node app.js",
// "serve": "cross-env NODE_ENV=development nodemon app.js"
// TODO 11. Добавляем middleware в app.js
// app.use(express.json());
// app.use(express.urlencoded({ extended: false }));
// TODO 12. Подключаем MongoDB:
// Создаем в config/default.json новую константу ("mongoUri": "") с пустым значением
// Удаляем дублирующий app.listen и создаем в app.js функцию start и помещаем в неё слушатель порта:
// async function start() {
//     try {
//         await mongoose.connect(config.get("mongoUri"));
//         app.listen(PORT, () => {
//             console.log(chalk.green(`Server has been started on port ${PORT}`));
//         });
//     } catch (error) {
//         console.log(chalk.red(error.message));
//         process.exit(1)
//     }
// };
// start();
// ---------------------------------------------
// Переходим в Clever Cloud https://console.clever-cloud.com/ и авторизуемся
// Cлева вверху нажимаем “Personal space” → “Create” → “an add-on”
// Ищем MongoDB и нажимаем “SELECT”
// Далее выбираем тариф и внизу нажимаем “NEXT”
// Придумываем название для базы данных и нажимаем “NEXT”
// Попадаем в dashboard (Database Credentials)
// Открываем MongoDB Compass
// Нажимаем “New connection”
// В URI переносим данные из поля Connection URI из dashboard (нужно открыть поле, нажав на замочек справа)
// Нажимаем Advanced Connection Options
// Вкладку General не трогаем
// Переходим на вкладку Authentication и выбираем Username/Password
// В поле Username передаем данные из поля User из dashboard
// В поле Password передаем данные из поля Password из dashboard
// В поле Authentication Database передаем данные из поля Database Name из dashboard
// Переходим на вкладку TLS/SSL
// Жмём on
// Жмём Connect
// Передаем значение из поля “Connection URI” из dashboard в переменную mongoUri в config/default.json
// TODO 13. Заносим первоначальные данные в БД:
// В app.js, внутри try функции start(), устанавливаем разовое событие (once - разовое событие, on - постоянное событие), которое будет отрабатывать при подключении базе данных (mongoose.connection.once("open", () => {initDatabase()}))
// Создаём новую папку startUp на одном уровне с config и в ней создаём файл initDatabase.js
// Подключаем initDatabase в app.js (const initDatabase = require("./startUp/initDatabase");)
// Создаём новую папку mock на одном уровне с config и в ней создаём файлы для каждой из сущностей.
// Наполняем файлы данными тех сущностей, которые необходимо загрузить, в формате массива объектов.
// Создаём новую папку models на одном уровне с config и в ней создаём модели для каждой из сущностей проекта (см. server\models\Profession.js).
// В файле initDatabase настраиваем запрос и заливку данных, которые необходимы для первоначальной заливки или которые проверять и, при необходимости, перезаливать при каждом запуске приложения (см. - server\startUp\initDatabase.js).
// Запускаем приложение npm run serve и проверяем в MongoDBCompass
// TODO 14. Создаём остальные модели:
// Создаём файлы моделей в папке models
// Задаём им schema, согласно полям объектов данных сущностей (см. server\models\User.js или server\models\Comment.js)
// TODO 15. Создаем структуру роутов
// Создаём новую папку routes на одном уровне с config и в ней создаём файл index.js
// Создаём переменную для роутов (см. server\routes\index.js):
// const express = require("express");
// const router = express.Router({ mergeParams: true });
// module.exports = router;
// -----------------------------------------------------
// Импортируем роуты в app.js (const routes = require("./routes"))
// Добавляем middleware для роутов в app.js (app.use("/api", routes)) (в результате все бэкэнд-роуты будут начинаться с "/api")
// -----------------------------------------------------
// Составляем перечень требуемых роутов (как в https://vladilen.notion.site/Api-Endpoints-9c0dc0d186c84447b293c0ac986e6c00)
// Создаем роуты по следующему циклу:
// Создаём в папке routes файл для роута (напр., auth.routs.js)
// Подключаем его в index.js (напр., router.use("/auth", require("./auth.routs")))
// Добавляем в него (напр., auth.routs.js) базовое наполнение:
// const express = require("express");
// const router = express.Router({ mergeParams: true });
// module.exports = router;
// -------------------------
// Составляем перечень методов, требуемых к реализации (как в https://vladilen.notion.site/Api-Endpoints-9c0dc0d186c84447b293c0ac986e6c00)
// И так для каждого роута
// TODO 16. Реализуем методы. Реализация метода простого запроса данных представлена в server\routes\profession.routs.js, прочие методы реализованы в соответствующих файлах.
// TODO 17. Запускаем оба проекта (и клиент и сервер) на двух терминалах
// TODO 18. Меняем все адресные строки запроса, напр. "apiEndPoint" на "http://localhost:8080/api/" и удаляем все json
// TODO 19. Меняем interceptors, чтобы он работал без привязки к FireBase (см. client\src\services\httpService.js):
// Выносим const expiresDate = localStorageService.getTokenExpiresDate(); и const refreshToken = localStorageService.getRefreshToken(); до блока if
// Добавляем else, в который копируем функционал проверки срока токена и обновления. Меняем поля токена и config. Меняем config.params на config.headers
// Поля токена нужно также изменить в localStorageService
// TODO 20. Для исправления ошибки CORS (запрет на кроссдоменные запросы) нужно на сервере:
// установить пакет npm i cors
// В app.js добавить const cors = require("cors");
// В app.js добавить app.use(cors());
// TODO 21. Корректируем метод singUp (client\src\store\users.js)
// TODO 22. Убираем искусственную генерацию Id из всех методов
// TODO 23. В методе login нужно поменять местами функции setTokens и dispatch так, чтобы setTokens шла первой. В dispatch нужно передать userId: data.userId

// =============================================================

// ! Алгоритм развертывания проекта

// ! Убрать homepage из package.json и из всех роутов и ссылок.

// TODO Делаем npm run build клиентской части приложения.

// TODO В app.js серверной части поключаем "const path = require("path");", затем пишем код:
// if (process.env.NODE_ENV === "production") {
//     app.use("/", express.static(path.join(__dirname, "client")))

//     const indexPath = path.join(__dirname, "client", "index.html")

//     app.get("*", (req, res) => {
//         res.sendFile(indexPath)
//     })
// }

// TODO Копируем в папки client и server файл .dockerignore, а в корневую папку Dockerfile

// TODO Запускаем докер и создаём образ при помощи "docker build -t jfd ." (jfd - произвольное имя образа, а . - местоположение докер-файла)
// ! Для каждого проекта образ делается только один раз
// Для проверки можно ввести команду "docker image ls". Должна отобразится строка с версией образа

// ! Для удаления образа используется команда "docker image rm jfd"

// ? Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them

// TODO Создаем контейнер при помощи "docker run -d -p 8080:8080 --name jfd --rm jfd" (jfd - заданное ранее имя образа)
// Для проверки можно ввести команду "docker ps -a" и перейти на http://localhost:8080/

// ! Остановить докер можно при помощи "docker stop jfd"

// TODO Сгенерировать ssh-ключ, с помощью "ssh-keygen -t rsa"

// TODO Получить ssh-ключ, с помощью "cat ~/.ssh/id_rsa.pub"

// TODO Создать сервер и добавить ssh-ключ

// TODO В папке client поменять localhost:8080 (в config.json) на IP созданного сервера ("apiEndPoint": "http://82.148.16.29/api/")

// TODO Подключаем git
// git init
// git add .
// git commit -m "initial"
// git remote add origin
// git push -u origin master

// TODO Размещаем сайт на сервере
// Вводим в консоль "ssh root@82.148.16.29" (нужно скопировать с сервера)
// Вводим в консоль "ls"
// Вводим в консоль "apt install git"
// Копируем ссылку на репозиторий из выпадающего меню code
// Вводим в консоль "git clone" и ссылка на репозиторий (напр. "git clone https://github.com/Elon26/diplom-for-deploy.git")
// Вводим в консоль "ls" и проверяем, что репозиторий был подключен
// Вводим в консоль "cd diplom-for-deploy/" и переходим в папку проекта
// Cоздаём образ на сервере при помощи "docker build -t jfd ."
// Проверяем при помощи "docker image ls"

// TODO Создаем контейнер при помощи "docker run -d -p 80:8080 --name jfd --rm jfd"

// TODO Проверяем при помощи "docker ps"

// TODO На этом этапе на сайт можно заходить. Для этого нужно скопировать ip-адрес в адресную строку браузера.

// =============================================================
